import { isWhiteSpace } from "../charcode.js";
import { defineCodeFix, getNodeForTarget, getSourceLocation } from "../diagnostics.js";
import { SyntaxKind, } from "../types.js";
export function createSuppressCodeFix(diagnosticTarget, warningCode, suppressionMessage = "") {
    return defineCodeFix({
        id: "suppress",
        label: `Suppress warning: "${warningCode}"`,
        fix: (context) => {
            const location = findSuppressTarget(diagnosticTarget);
            if (!location) {
                return undefined;
            }
            const { lineStart, indent } = findLineStartAndIndent(location);
            const updatedLocation = { ...location, pos: lineStart };
            return context.prependText(updatedLocation, `${indent}#suppress "${warningCode}" "${suppressionMessage}"\n`);
        },
    });
}
function findSuppressTarget(target) {
    if ("file" in target) {
        return target;
    }
    const nodeTarget = getNodeForTarget(target);
    if (!nodeTarget)
        return undefined;
    const node = findSuppressNode(nodeTarget);
    return getSourceLocation(node);
}
/** Find the node where the suppression should be applied */
function findSuppressNode(node) {
    switch (node.kind) {
        case SyntaxKind.Identifier:
        case SyntaxKind.TypeReference:
        case SyntaxKind.UnionExpression:
        case SyntaxKind.ModelExpression:
            return findSuppressNode(node.parent);
        default:
            return node;
    }
}
function findLineStartAndIndent(location) {
    const text = location.file.text;
    let pos = location.pos;
    let indent = 0;
    while (pos > 0 && text[pos - 1] !== "\n") {
        if (isWhiteSpace(text.charCodeAt(pos - 1))) {
            indent++;
        }
        else {
            indent = 0;
        }
        pos--;
    }
    return { lineStart: pos, indent: location.file.text.slice(pos, pos + indent) };
}
//# sourceMappingURL=suppress.codefix.js.map