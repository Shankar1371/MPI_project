import { TextDocumentIdentifier } from "vscode-languageserver";
import { TextDocument } from "vscode-languageserver-textdocument";
import { ServerLog } from "./types.js";
interface PendingUpdate {
    latest: TextDocument | TextDocumentIdentifier;
    latestUpdateTimestamp: number;
}
export type UpdateType = "opened" | "changed" | "closed" | "renamed";
type UpdateCallback = (updates: PendingUpdate[]) => Promise<void>;
/**
 * Track file updates and recompile the affected files after some debounce time.
 */
export declare class UpdateManger {
    #private;
    private _log;
    constructor(log: (sl: ServerLog) => void);
    setCallback(callback: UpdateCallback): void;
    get docChangedVersion(): number;
    private bumpDocChangedVersion;
    private pushDocChangedTimestamp;
    private readonly WINDOW;
    private readonly DEFAULT_DELAY;
    private readonly DELAY_CANDIDATES;
    private getWindowedDocChangedTimesteps;
    private getAdaptiveDebounceDelay;
    scheduleUpdate(document: TextDocument | TextDocumentIdentifier, UpdateType: UpdateType): void;
}
/**
 * Debounces a function but also waits at minimum the specified number of milliseconds until
 * the next invocation. This avoids needless calls when a synchronous call (like diagnostics)
 * took too long and the whole timeout of the next call was eaten up already.
 *
 * @param fn The function
 * @param milliseconds Number of milliseconds to debounce/throttle
 */
export declare function debounceThrottle(fn: () => void | Promise<void>, getDelay: () => number, log: (sl: ServerLog) => void): () => void;
export {};
//# sourceMappingURL=update-manager.d.ts.map