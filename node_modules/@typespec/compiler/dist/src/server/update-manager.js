import { ENABLE_UPDATE_MANAGER_LOGGING } from "./constants.js";
/**
 * Track file updates and recompile the affected files after some debounce time.
 */
export class UpdateManger {
    #pendingUpdates = new Map();
    #updateCb;
    // overall version which should be bumped for any actual doc change
    #docChangedVersion = 0;
    #scheduleBatchUpdate;
    #docChangedTimesteps = [];
    _log;
    constructor(log) {
        this._log =
            typeof process !== "undefined" &&
                process?.env?.[ENABLE_UPDATE_MANAGER_LOGGING]?.toLowerCase() === "true"
                ? (sl) => {
                    log({ ...sl, message: `#FromUpdateManager: ${sl.message}` });
                }
                : () => { };
        this.#scheduleBatchUpdate = debounceThrottle(async () => {
            const updates = this.#pendingUpdates;
            this.#pendingUpdates = new Map();
            if (updates.size > 0) {
                await this.#update(Array.from(updates.values()));
            }
        }, this.getAdaptiveDebounceDelay, this._log);
    }
    setCallback(callback) {
        this.#updateCb = callback;
    }
    get docChangedVersion() {
        return this.#docChangedVersion;
    }
    bumpDocChangedVersion() {
        this.#docChangedVersion++;
    }
    pushDocChangedTimestamp() {
        const now = Date.now();
        this.#docChangedTimesteps = [...this.getWindowedDocChangedTimesteps(), now];
    }
    WINDOW = 5000;
    DEFAULT_DELAY = 500;
    // Provider different debounce delay according to whether usr are actively typing, increase the delay if so to avoid unnecessary invoke
    // The category below is suggested from AI, may adjust as needed in the future
    DELAY_CANDIDATES = [
        // IMPORTANT: sort by frequencyInWindow desc, we will pick the first match
        {
            // active typing
            frequencyInWindow: 20,
            delay: 1000,
        },
        {
            // moderate typing
            frequencyInWindow: 10,
            delay: 800,
        },
        {
            // light typing
            frequencyInWindow: 0,
            delay: this.DEFAULT_DELAY,
        },
    ];
    getWindowedDocChangedTimesteps() {
        const now = Date.now();
        return this.#docChangedTimesteps.filter((timestamp) => {
            const age = now - timestamp;
            return age < this.WINDOW;
        });
    }
    getAdaptiveDebounceDelay = () => {
        const frequent = this.getWindowedDocChangedTimesteps().length;
        for (const c of this.DELAY_CANDIDATES) {
            if (frequent >= c.frequencyInWindow) {
                return c.delay;
            }
        }
        return this.DEFAULT_DELAY;
    };
    scheduleUpdate(document, UpdateType) {
        if (UpdateType === "changed" || UpdateType === "renamed") {
            // only bump this when the file is actually changed
            // skip open
            this.bumpDocChangedVersion();
            this.pushDocChangedTimestamp();
        }
        const existing = this.#pendingUpdates.get(document.uri);
        if (existing === undefined) {
            this.#pendingUpdates.set(document.uri, {
                latest: document,
                latestUpdateTimestamp: Date.now(),
            });
        }
        else {
            existing.latest = document;
            existing.latestUpdateTimestamp = Date.now();
        }
        this.#scheduleBatchUpdate();
    }
    async #update(updates) {
        await this.#updateCb?.(updates);
    }
}
/**
 * Debounces a function but also waits at minimum the specified number of milliseconds until
 * the next invocation. This avoids needless calls when a synchronous call (like diagnostics)
 * took too long and the whole timeout of the next call was eaten up already.
 *
 * @param fn The function
 * @param milliseconds Number of milliseconds to debounce/throttle
 */
export function debounceThrottle(fn, getDelay, log) {
    let timeout;
    let lastInvocation = undefined;
    let executingCount = 0;
    let debounceExecutionId = 0;
    const UPDATE_PARALLEL_LIMIT = 2;
    function maybeCall() {
        clearTimeout(timeout);
        timeout = setTimeout(async () => {
            if (lastInvocation !== undefined &&
                (Date.now() - lastInvocation < getDelay() || executingCount >= UPDATE_PARALLEL_LIMIT)) {
                maybeCall();
                return;
            }
            const curId = debounceExecutionId++;
            const s = new Date();
            try {
                executingCount++;
                log({
                    level: "debug",
                    message: `Starting debounce execution #${curId} at ${s.toISOString()}. Current parallel count: ${executingCount}`,
                });
                await fn();
            }
            finally {
                executingCount--;
                const e = new Date();
                log({
                    level: "debug",
                    message: `Finish debounce execution #${curId} at ${e.toISOString()}, duration=${e.getTime() - s.getTime()}. Current parallel count: ${executingCount}`,
                });
            }
            lastInvocation = Date.now();
        }, getDelay());
    }
    return maybeCall;
}
//# sourceMappingURL=update-manager.js.map